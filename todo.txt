PLANNED FEATURES!!!!! YIPPEE!!!
- a full plugin manager (yes, ambitious. but in theory very fucking simple)

1. Test Structure & Lifecycle
- asynchronous test support (async setUp/tearDown)
- support fixtures (setup and cleanup routines for tests):
  - setUp() / tearDown(): per-test initialization and cleanup
  - setUpClass() / tearDownClass(): one-time setup/cleanup for an entire test class
  - beforeAll / afterAll, around each test (sync & async)
- extensible lifecycle hooks (beforeAll, afterAll, around each test)

2. Parameterization & Data-Driven Testing
- parameterized / test-data driven tests
- Enable parameterized tests with a decorator or data-driven API:
  ```python
  def parameterize(cases):
      def wrapper(fn):
          # generate one test per case
          return fn
      return wrapper
  ```

3. Assertions & Performance
- built-in timing and performance assertions
- clear, human-readable failure output
- support for custom assertion extensions
- error aggregation and traceback enhancement

4. Execution Control & Test Discovery
- test discovery hooks (automatic test method collection)
- test execution ordering controls
- parallel / concurrent test execution support
- custom test skip / retry logic
- skip / xfail decorators or annotations

5. Extensibility & Integration
- compatibility layer for popular test frameworks
- integration with mock / stub utilities
- pluggable runners and reporters
- result caching like pytest
- seamless IDE / test-runner integration

6. Reporting & Developer Tools
- logging capture and inspection
- test metadata (custom labels, descriptions, severity levels)
- tagging or markers to group and filter tests
- test suite composition (nesting and grouping)
- resource management (temporary files/directories, database fixtures)
- extensive documentation and examples
- create a domain specific lang. i want it to look like:

from ntest import describe, it, raises

# "it" returns a TestBuilder with a .run() method. this is where the action itself goes
describe("Calculator"):

  it("adds two numbers",
     params=[(1, 2, 3), (5, 7, 12)]) \
  .run(lambda a, b, expected:
     assert Calculator.add(a, b) == expected)

  it("throws on overflow") \
  .run(lambda:
     with raises(OverflowError):
       Calculator.add(10**1000, 10**1000))
